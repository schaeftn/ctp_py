import sys

sys.path.append("/home/tristan/projects/ctp_py/src")

from org.combinators.ctp.py.sampling.FclMotionValidator import *
from org.combinators.ctp.py.sampling.FclStateValidator import *
from org.combinators.ctp.py.sampling.PathRefinement import *

from enum import Enum
import asyncio

try:
    from ompl import util as ou
    from ompl import base as ob
    from ompl import geometric as og
except ImportError:
    # if the ompl module is not in the PYTHONPATH assume it is installed in a
    # subdirectory of the parent directory called "py-bindings."
    from os.path import abspath, dirname, join
    import sys

    sys.path.insert(0, join(dirname(dirname(abspath(__file__))), 'py-bindings'))
    from ompl import util as ou
    from ompl import base as ob
    from ompl import geometric as og



class MyMotionValidator(ob.MotionValidator):
    def __init__(self, si, scene_):
        super(MyMotionValidator, self).__init__(si)
        self.scene = scene_
        self.state = ob.State(ob.SE3StateSpace())

    def checkMotion(self, *args, **kwargs):
        s1 = args[0]
        s2 = args[1]
        valid_motion = False

        if args.__len__() == 2:
            valid_motion, min_val = self.scene.check_free_line_3d(
                [s1.getX(), s1.getY(), s1.getZ()],
                [s2.getX(), s2.getY(), s2.getZ()])

        if args.__len__() == 3:
            valid_motion, col_param = self.scene.check_free_line_3d(
                [s1.getX(), s1.getY(), s1.getZ()],
                [s2.getX(), s2.getY(), s2.getZ()])
            min_val = col_param - 0.01 if col_param - 0.01 >= 0.0 else 0.0
            x = s1.getX() + min_val * (s2.getX() - s1.getX())
            y = s1.getY() + min_val * (s2.getY() - s1.getY())
            z = s1.getZ() + min_val * (s2.getZ() - s1.getZ())
            args[2].first.setX(x)
            args[2].first.setY(y)
            args[2].second = min_val

        return valid_motion


# check https://github.com/kucars/laser_collision_detection/blob/1b78fe5a95584d135809b1448d33675bb8fee250/src/laser_obstacle_detect.cpp#L252
# data format, resolution, ansonsten check api fcl...
class plan:
    def __init__(self):
        #self.scene = $sbmp_main.sceneRep$
        # construct the state space we are planning in
        space = ob.SE3StateSpace()

        # set the bounds
        $sbmp_main.r3bounds$

        class Samplers(Enum):
            OBSTACLEBASED = 1
            UNIFORM = 2
            GAUSSIAN = 3
            MAXCLEARANCE = 4
            CUSTOM = 5

        def getSampler(si):
            samplerId = $sbmp_main.samplerMember$
            switcher = {
                Samplers.OBSTACLEBASED: ob.ObstacleBasedValidStateSampler(si),
                Samplers.UNIFORM: ob.UniformValidStateSampler(si),
                Samplers.GAUSSIAN: ob.GaussianValidStateSampler(si),
                Samplers.MAXCLEARANCE: ob.MaximizeClearanceValidStateSampler(si),
                Samplers.CUSTOM: PathRefinementSampler(si)
            }
            return switcher.get(samplerId)

        def getStateSpaceSampler(sp):
            print(f"getSampler")
            samplerId = Samplers.CUSTOM
            switcher = {
                Samplers.UNIFORM: ob.CompoundStateSampler(sp),
                Samplers.GAUSSIAN: ob.CompoundStateSampler(sp),
                Samplers.CUSTOM: PathRefinementSpSampler(sp)
            }
            print(f"returning: {switcher.get(samplerId)}")
            return switcher.get(samplerId)

$sbmp_main.startstop$

        #space.setStateSamplerAllocator(ob.StateSamplerAllocator(getStateSpaceSampler))
        $sbmp_main.spaceSampler$
        self.si = ob.SpaceInformation(space)
        #self.si.setMotionValidator(ob.DiscreteMotionValidator(self.si))
        $sbmp_main.motionValidator$
        $sbmp_main.stateValidator$
        $sbmp_main.stateValidatorResolution$
        $sbmp_main.validStateSamplerAlloc$

$sbmp_main.cost$
        self.ss = og.SimpleSetup(self.si)
        $plannerMainPlannerInst$
        self.ss.setStartAndGoalStates(start, goal)
        self.ss.setup()
        self.ss.getPlanner().checkValidity()

        self.solve()
        np.set_printoptions(formatter={'float':'{:0.5f}'.format})
        #print(f"solution path:")
        #[print(f"RealVectorState {v}") for v in path_data.path_list]

    def solve(self):
        solved = self.ss.solve(10.0)
        if solved and self.ss.haveExactSolutionPath():
            print("Found solution:")
            $sbmp_main.simplify$
        else:
            print("No exact solution found")

        data = ob.PlannerData(self.si)
        self.ss.getPlannerData(data)

        explored_states = []
        for i in range(0, data.numVertices()):
            coords = []
            state = data.getVertex(i).getState()

            coords.append(state.getX())
            coords.append(state.getY())
            coords.append(state.getZ())
            explored_states.insert(i, coords)
        explored_states = []
        print(f"solution path:")

        print(f"""{{"exploredStates" : {explored_states}}}""")

        if self.ss.haveSolutionPath():
            print(f"solution path: {self.ss.getSolutionPath()}")
        else:
            print(f"WARN: no solution path")

    def isStateValid(self, state):
        return self.scene.is_valid([state.getX(), state.getY(), state.getZ()])

    @staticmethod
    def getStateVector(s):
        return [s.getX(), s.getY(), s.getZ()]


if __name__ == '__main__':
    p = plan()